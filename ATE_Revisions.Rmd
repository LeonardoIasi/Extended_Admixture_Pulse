---
title: "Revisions"

author: Leonardo Nicola Martin Iasi (Max Planck Institute for Evolutionary Anthropology,
  MPI EVA), Dr. Benjamin Marco Peter (MPI EVA, benjamin_peter@eva.mpg.de)
date: "`r Sys.Date()`"
output:
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
    fig_caption: yes
    citation_package: natbib
#    template: ATE_modified.tex
#  html_document:
#    code_folding: hide
#    toc: yes
#    toc_depth: 4
#    toc_float:
#      collapsed: no
#    citation_package: natbib
#  md_document:
#    toc: yes
#    variant: markdown_github
#    citation_package: natbib
#  bookdown::word_document2:
#    fig_caption: yes
#    toc: yes
#    toc_depth: '4'
#  github_document:
#    toc: yes
#    citation_package: natbib
header-includes:
- \usepackage{setspace}
- \doublespacing
- \usepackage[none]{hyphenat}
- \usepackage{amsfonts}
- \usepackage{amssymb}
- \usepackage{graphicx}
- \usepackage{float}
- \usepackage{xcolor}
- \floatplacement{figure}{H}

#csl: References/chicago-author-date.csl
bibliography: References/MyLibraryATE.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
#Make code wrap text so it doesn't go off the page when Knitting to PDF
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

<style>
body {
text-align: justify}
</style>

\maketitle
\section{Titles}
\begin{enumerate}
    \item An extended admixture pulse model reveals the limitation to the dating of Human-Neandertal introgression Revisions
\end{enumerate}


```{r message=FALSE, echo=F,warning=FALSE}
suppressPackageStartupMessages({
  library(VGAM)
  library(tidyverse)
  library(ggplot2)
  library(reshape)
  library(viridis)
  library(ggpubr)
  library(dplyr)
  library(rethinking)
  library(kableExtra)
  library(DEoptim)
  library(png)
  library("MASS")
  library(bbmle)
  #library(DPQ)
  library(flextable)
  library(officer)
})

Results_Table <- function(Table_Path) {
  header_for_Result=c("A","m","c","RSS_Expo","error","Scenario","GF_Start","GF_Stop","Ascertained","min_dist","Gene_Flow_Model")
  Raw_results <-  read.table(Table_Path, header = F,col.names = header_for_Result)
  Raw_results$mean.t.GF <- rowMeans(Raw_results[c('GF_Start', 'GF_Stop')], na.rm=TRUE)
  Raw_results$length.t.GF <- Raw_results$GF_Stop - Raw_results$GF_Start
  Raw_results$GF[Raw_results$length.t.GF== 1]="0_Pulse"
  Raw_results$GF[Raw_results$length.t.GF > 1]="Continous"
  Raw_results$Ascertainment[Raw_results$Ascertained== 0]="0_LES"
  Raw_results$Ascertainment[Raw_results$Ascertained == 1]="HES"
  Raw_results$min_dist <- as.factor(Raw_results$min_dist)
  Raw_results$GF[Raw_results$Gene_Flow_Model== "GF_Model_I"]="0_Pulse"
  return(Raw_results)
}


Get_Data_Table <- function(Data,mean_Gamma=F){
  xx=as.data.frame(table(round(Data$m,digits = 0), paste(Data$GF,Data$mean.t.GF, sep="_"),Data$mean.t.GF,Data$GF,Data$mean.t.GF,Data$length.t.GF))
  xx=subset(xx,Freq>0)
  xx=xx[order(xx$Var3),]
  return(xx)
}

Get_points <- function(input,lval,hval,log){
  # Read input file
  data <- read.table(input, header = F)
  
  
  # set dist and wcorr
  col=2
  dist <- data[,1]
  wcorr <- data[,col]
  ndist <- length(dist)  ## number of rows in dataset
  lval=lval
  hval=hval
  
  # check x lower value and y lower value
  data.sub <- data
  if ((lval > dist[1]) || (hval < dist[ndist])) {
    data.sub <- subset(data, ((dist <= hval) & (dist >= lval)))
  } 
  dist <- data.sub[,1]		# updated x values
  wcorr <- data.sub[,col]		# updated y values
  if(log==T){
    xx <- cbind(dist,log(wcorr))
    xx <- xx[complete.cases(xx),]
    wcorr <- xx[,2]
    wcorr <-c(wcorr,rep(NA,length(data.sub[,1])-length(wcorr)))
    dist <- xx[,1]
    dist <-c(dist,rep(NA,length(data.sub[,1])-length(dist)))
  }
  result_table <- data.frame(dist,wcorr)
  return(result_table)
}

Figure_1_C_1 <- function(input,log,Colour_P){
  
  Pulse <- Get_points(input[1],lval=0.05,hval=0.6,log)
  Continous <- Get_points(input[2],lval=0.05,hval=0.6,log)
  P_C_Data <- data.frame(Pulse,Continous)
  P_C_Data <- P_C_Data[P_C_Data$wcorr > -13,]
  
  Px <-  ggplot(data=P_C_Data,aes(y=wcorr,x=dist))+
    geom_point(aes(x=dist,y=wcorr),color=Colour_P[1],pch=4)+
    geom_point(aes(x=dist.1,y=wcorr.1),color=Colour_P[6],pch=18)+
    labs(y = "log weighted LD")+
    labs(x = "Genetic Distance in cM")
  #coord_cartesian(ylim = c(-13,-8),xlim=c(0,0.4),expand = 0)
  
  return(Px)
  
}

Figure_All_Real_Data <- function(input,log,GF_length,Colour_P){
  
  Real_Data <- c()
  for(i in input){
    xx <-Get_points(i,lval=0.05,hval=0.5,log)
    Real_Data <- c(Real_Data,xx)
  }
  Real_Data <- as.data.frame(Real_Data)
  Real_Data_names <- c()
  for(i in GF_length){
    Real_Data_names <- c(Real_Data_names,c('Genetic_Distance',i))
  }
  colnames(Real_Data) <- Real_Data_names
  Real_Data.melted <- melt(Real_Data, id = c("Genetic_Distance"))
  
  Px <-  ggplot(data =Real_Data.melted, aes(x = Genetic_Distance, y = value,color=variable)) +
    geom_point(pch=18)+
    coord_cartesian(ylim = c(-8,-14),expand = 0,xlim = c(0,0.5))+
    #geom_vline(xintercept=Split_time,linetype=3,color='black')+
    scale_color_manual(values = Colour_P)+
    labs(x = "Genetic distance")+
    labs(y = "log weighted LD")+
    labs(color="Admixture Duration")
  return(Px)
  
}

Figure_1_C_2 <- function(Timespan_GF_Models,time_l,Split_time,Mean_Time,Colour_P,max_y,max_x){
  
  n_GF_Models=length(Timespan_GF_Models)
  time=seq(1,time_l,1)
  
  Gamma_fun <- function(GF_Length,time_l,Split_time,Mean_Time){
    time=seq(1,time_l,1)
    EX= Mean_Time
    VarX= (GF_Length/4)**2
    b= EX/VarX
    a=EX*b
    
    GF_gamma <- dgamma(x=time,shape = a,scale = 1/b)
    GF_gamma[GF_gamma < 1e-6] = 0
    GF_gamma <- GF_gamma[1:time_l]
    m2 <- c()
    for (i in GF_gamma){
      x <- i*(0.03/sum(GF_gamma))
      m2 <- c(m2,x)
    }
    #m2 <- c(m2,rep(0,time_l-Split_time))
    #m2 <- c(m2,rep(0,time_l))
    #cutoff_in_Percent=(sum(m2[2550:5001])/0.03)*100
    
    GF <- c(m2)
    return(GF)
  }
  GF <- c(seq(1,time_l,1))
  for(i in 1:n_GF_Models){
    Timespan <- Timespan_GF_Models[i]
    GF_x <- Gamma_fun(Timespan,time_l,Split_time,Mean_Time)
    GF <- cbind(GF,GF_x)
  }
  GF <- as.data.frame(GF)
  colnames(GF) <- c('Time',Timespan_GF_Models)
  GF.melted <- melt(GF, id = "Time")
  Px <-  ggplot(data =GF.melted, mapping=aes(x = Time, y = value,color=variable,fill=variable)) +
    # outcomented part colors the area of t_d
    #geom_area(position = 'identity',mapping = aes(x = ifelse(Time>Mean_Time-(as.numeric(as.character(variable))/2) & Time< Mean_Time+(as.numeric(as.character(variable))/2) , Time, NA),fill=variable),show.legend = F,alpha = 0.33)+
    geom_area(position = 'identity',mapping = aes(x = ifelse(Time<Mean_Time-(as.numeric(as.character(variable))/2) 
     , Time, NA),fill=variable),show.legend = F,alpha = 0.33)+
    geom_area(position = 'identity',mapping = aes(x = ifelse(Time>Mean_Time+(as.numeric(as.character(variable))/2) 
       , Time, NA),fill=variable),show.legend = F,alpha = 0.33)+
    geom_line(show.legend = F)+
    coord_cartesian(ylim = c(0,1e-04),xlim = c(0,3050),expand = 0)+
    geom_vline(xintercept=Split_time,linetype=3,color='black')+
    scale_color_manual(values = Colour_P)+
    scale_fill_manual(values = Colour_P)+
    labs(x = "Time in Generations")+
    labs(y = "Migration Rate")+
    labs(color="Admixture Duration")
  return(Px)
}


Theoratical_Lomax <- function(Timespan_GF_Models,max_Genetic_distance,Split_time,Mean_Time,Intercept,Colour_P){
  n_GF_Models=length(Timespan_GF_Models)
  
  Lomax_fun <- function(GF_Length,max_Genetic_distance,Split_time,Mean_Time,Intercept,log=T){
    Genetic_length=seq(0.01,max_Genetic_distance,0.01)
    EX= Mean_Time
    VarX= (GF_Length/4)**2
    b= EX/VarX
    a=EX*b
    Theta=b
    k=a+1
    Lomax_normal <- function(dist,k,theta,A) A*(1 + ((dist/100) /  theta))^-(k)
    Lomax_log <- function(dist,k,theta,A) -k* log(1 + ((dist/100) /  theta)) + log(A)
    if(log==T){
      ALD <-  Lomax_log(dist=Genetic_length,k = k ,theta = Theta, A=Intercept)
    }
    else{
      ALD <-  Lomax_normal(dist=Genetic_length,k = k ,theta = Theta, A=Intercept)
    }
    Lomax_Result <- cbind(Genetic_length,ALD,k,Theta)
    return(Lomax_Result)
  }
  Lomax_Result <- c()
  for(i in Timespan_GF_Models){
    xx=Lomax_fun(i,max_Genetic_distance,Split_time,Mean_Time,Intercept,log=T)
    Lomax_Result <- cbind(Lomax_Result,xx)
  }
  Lomax_Result <- as.data.frame(Lomax_Result)
  colnames_Lomax_Result <- c()
  for(time in Timespan_GF_Models){
    colnames_Lomax_Result <- c(colnames_Lomax_Result,c('Genetic_Distance',time,'k','Theta'))
  }
  colnames(Lomax_Result) <- colnames_Lomax_Result
  Lomax_Result.melted <- melt(Lomax_Result, id = c("Genetic_Distance",'k','Theta'))
  Px <-  ggplot(data =Lomax_Result.melted, aes(x = Genetic_Distance, y = value,color=variable)) +
    geom_line()+
    #coord_cartesian(ylim = c(0,max(ALD$'2')),expand = 0)+
    coord_cartesian(ylim = c(-14,-8),expand = 0,xlim = c(0,0.5))+
    #geom_vline(xintercept=Split_time,linetype=3,color='black')+
    scale_color_manual(values = Colour_P)+
    labs(x = "Genetic distance (cM)")+
    labs(y = "log weighted LD")+
    labs(color="Admixture Duration")
  return(Px)
}

t_d=c(1,100,200,400,800,1000,1500,2000,2500)

```

# Power Analysis to differentiat an extended from a simple pulse



Here we want to know for which duration and time since admixture we can differentiate an extended from a simple admixture pulse. We take a best case scenario were admixture segments are perfectly known. First, we compare the likelihood of the data simulated from a lomax distribution using different admixture durations, under the extended and simple pulse and perform a likelihood ratio test to find the parameter region where we can confidently distinguish these models.

## Fixed mean time

First, we fix the mean time of admixture to 1500 generation with different durations and calculate the likelihood of the data given the two models. We perform a likelihood ratio test with a significance cutoff of + 2. We perform each simulation 100 times with different amount of data. Our maximum amount is 200000 unique segments as observed in Skov et al. 2020. Here around 200000 unique segments, were identified in Icelandic genomes using a posterior probability cutoff of 0.8 to identify the segment using an HMM (Skov et al. 2018).


```{r eval=F,message=FALSE, echo=FALSE,warning=FALSE}

LRT_fn <- function(seg,tm,k){
  ll_sp=sum(dexp(x = seg,rate = tm,log = T))
  ll_ep=sum(dlomax(x=seg,shape3.q = k,scale = k/tm,log=T))
  LRT = -2*(ll_sp - ll_ep)
  return(LRT)
}  


simulate_pulse=function(n_segments,tm,td){
  k = 1/((td/(4*tm))^2)
  sim_r = VGAM::rlomax(n=n_segments,shape3.q = k,scale = k/tm)
  LRT = LRT_fn(sim_r,tm,k)
  return(LRT)
}

n_seg=c(100,1000,10000,100000,200000)
Sim_1_fn <- function(n_seg,rep=100){
  LRT = cbind(
  P_td_1=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 1))),
  P_td_100=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 100))),
  P_td_200=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 200))),
  P_td_400=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 400))),
  P_td_800=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 800))),
  P_td_1000=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 1000))),
  P_td_1500=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 1500))),
  P_td_2000=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 2000))),
  P_td_2500=unlist(lapply(1:rep, function(x) simulate_pulse(n_segments = n_seg,tm = 1500,td = 2500)))
  )
  return(LRT)
} 

Sim_1=lapply(n_seg, function(x) Sim_1_fn(x,rep=100))



```


## influence of time-since-admixture

```{r eval=F,message=FALSE, echo=FALSE,warning=FALSE}

frag_through_time_fn <- function(t,t_closer){
  set.seed( runif(1, 1, 1e6))
  s_t0=rexp(1,t)
  s_t_closer=rexp(1,t-t_closer)
  seg_t <- c(s_t0,s_t_closer)
  return(seg_t)
}

simulate_closer=function(n_ti,tm,td,t_since_admixture){
  t_closer=tm - td/2 - t_since_admixture
  k=1/((td/(4*tm))^2)
  sim_r=rgamma(n_ti,shape = k,scale = tm/k)
  if(length(which(sim_r<=t_closer))==0){
      sim_r=sim_r
  }else{
    sim_r=sim_r[-which(sim_r<=t_closer)]    
  }
  while(length(sim_r)!=n_ti){
    sim_r=c(sim_r,rgamma(n_ti-length(sim_r),shape = k,scale = tm/k))
    if(length(which(sim_r<=t_closer))==0){
        sim_r=sim_r
    }else{
      sim_r=sim_r[-which(sim_r<=t_closer)]    
    }
  
  }
  seg.res <-  t(sapply(sim_r,function(x) frag_through_time_fn(x,t_closer = t_closer)))
  LRT_0 = LRT_fn(seg = seg.res[,1],tm,k)
  k=1/((td/(4*(tm-t_closer)))^2)
  LRT_closer = LRT_fn(seg = seg.res[,2],tm-t_closer,k)
  return(c(LRT_0,LRT_closer))
}


n_seg=c(100,1000,10000,100000,200000)
Sim_2_fn <- function(n_seg,rep=100){
  LRT = list(
  P_td_1=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 1,t_since_admixture=50))),
  P_td_100=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 100,t_since_admixture=50))),
  P_td_200=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 200,t_since_admixture=50))),
  P_td_400=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 400,t_since_admixture=50))),
  P_td_800=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 800,t_since_admixture=50))),
  P_td_1000=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 1000,t_since_admixture=50))),
  P_td_1500=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 1500,t_since_admixture=50))),
  P_td_2000=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 2000,t_since_admixture=50))),
  P_td_2500=t(sapply(1:rep, function(x) simulate_closer(n_ti = n_seg,tm = 1500,td = 2500,t_since_admixture=50)))
  )
  return(LRT)
} 

Sim_2=lapply(n_seg, function(x) Sim_2_fn(x,rep=100))
#save.image("ATE_Revisions.RData")

```

```{r figR1,message=FALSE, echo=FALSE,warning=FALSE,fig1.pos="H",fig.width=9,fig.height=9,fig.cap="\\label{fig:figR1} Liklihood ratios between the simple pulse and extended pulse model for different durations of admixture for 100, 1000, 10000 and 100000 segments. Boxplots from 100 replications."}

load("ATE_Revisions.RData")

par(mfrow=c(3,2))
for(i in 1:length(n_seg)){
  boxplot(log(Sim_1[[i]]),main = paste("number of segments = ",n_seg[i]),names=c(t_d),
          xlab="GF duration",ylab="LR",las=2)
  abline(h=log(2),col="red",lty=2)
}

```

```{r figR2,message=FALSE, echo=FALSE,warning=FALSE,fig1.pos="H",fig.width=9,fig.height=9,fig.cap="\\label{fig:figR2} Liklihood ratios between the simple pulse and extended pulse model for different durations of admixture for 100, 1000, 10000 and 100000 segments sampled at time 0 and 50 generations after the end of admixture. Boxplots from 100 replications."}

par(mfrow=c(3,2))
for(i in 1:length(n_seg)){
  boxplot(cbind(log(Sim_2[[i]]$P_td_1[,1]),log(Sim_2[[i]]$P_td_1[,2]),
            log(Sim_2[[i]]$P_td_100[,1]),log(Sim_2[[i]]$P_td_100[,2]),
            log(Sim_2[[i]]$P_td_200[,1]),log(Sim_2[[i]]$P_td_200[,2]),
            log(Sim_2[[i]]$P_td_400[,1]),log(Sim_2[[i]]$P_td_400[,2]),
            log(Sim_2[[i]]$P_td_800[,1]),log(Sim_2[[i]]$P_td_800[,2]),
            log(Sim_2[[i]]$P_td_1000[,1]),log(Sim_2[[i]]$P_td_1000[,2]),
            log(Sim_2[[i]]$P_td_1500[,1]),log(Sim_2[[i]]$P_td_1500[,2]),
            log(Sim_2[[i]]$P_td_2000[,1]),log(Sim_2[[i]]$P_td_2000[,2]),
            log(Sim_2[[i]]$P_td_2500[,1]),log(Sim_2[[i]]$P_td_2500[,2])
            ),names=c(rep(t_d,each=2)),main = paste("number of segments = ",n_seg[i]),
          xlab="GF duration",ylab="LR",col=rep(c('grey','green'),9),las=2)
  abline(h=log(2),col="red",lty=2)
}
```

# Wright-Fischer Model for msprime simulations

As described in Neslon et al. 2020 the algorithm in ms and msprime (the Hudson model), it is known that the coalescent is biased relative to the W-F-model when sample sizes are large or for events in the recent past. The Hudson algorithm results in unrealistic relatedness among samples due to having to many ancestors. This is a consequence of the recombination algorithm being designed to simulate small regions and does not account for multiple simultaneous recombinations during meiosis. This can have the effect of long-range correlations along the simulated genomes in large samples or under migration models. This correlation might then affect the dating of migration events since it influences the recombination clock. In Nelson et al. 2020 the deviation in the variance in ancestry proportion between the expected and msprim simulations under the Hudson model was observed for admixture events younger than 20 generations before sampling with 30% admixture proportion. This effect can be corrected by using a Wright-Fisher-model in the first generations of simulation and switch to the faster Hudson model afterwards. Although our smallest number of generations between end of admixture and sampling with a admixture fraction of 3% is 50  generations, we examined the effect of only using the Hudson model, as we did before, by comparing it to W-F & Hudson hybrid simulations for our scenario with the samlest number of generation between sampling and end of admixture. We run the same simulation used for Figure 4 A and B under a constant recombination rate. The W-F-model is run for 500 generations and switches to the Hudson afterwards. We replicated this 10 times and compared it to the original simulations only using the Hudson algorithm (100 replicates).

```{r eval=T,message=FALSE, echo=FALSE,warning=FALSE}
#### New Figure for Paper using recent sampling (50 gen): constant RR, RM no correction, RM diff RM correction, RM correction same RM ####

cbPalette_viridis <- viridis(6,option = "D")

Filter_Result_Table <- function(Result.Table){
  Result.Table=read.table(Result.Table,header=F,sep = " ")
  Result.names <- c('A.exp', 's.exp', 'c.exp', 'RSS_Expo','AIC_Expo', 'A.lomax', 's.lomax', 'w.lomax','c.lomax', 'RSS_Lomax','AIC_Lomax', 'F_Test','Scenario.name','GF.Start','GF.End','AS','minDist','GF.Model')
  colnames(Result.Table) <- Result.names
  #Result.Table <- Result.Table[(1/Result.Table$s.exp)>0,]
  #Result.Table <- Result.Table[(1/Result.Table$s.exp)<5000,]
  #Result.Table <- Result.Table[Result.Table$RSS_Lomax<1e-2,]
  return(Result.Table)
}

#### True values
True_params <- function(Result.Table){
  True_params_Calc <- function(True_GF_length,True_mean_GF){
    EX= True_mean_GF
    GF_Len <-True_GF_length
    VarX= ((GF_Len)/4)**2
    b= EX/VarX
    a=EX*b
    a=a
    True_W=1/a
    True_S=b/(1/True_W)
    xx=c(True_W,True_S)
    return(xx)
  }
  True.params <- c()
  for (i in 1:length(Result.Table$F_Test)) {
    xx=True_params_Calc(Result.Table$True_GF_length[i],Result.Table$True_mean_GF[i])
    True.params <- rbind(True.params,xx)
  }
  True.params <- as.data.frame(True.params)
  return(True.params)
}

Result.Table.fn <- function(Result.Table.path,Sampling.time.from.GF.End,name){
  Result.Table <- Filter_Result_Table(Result.Table.path)
  Result.Table$Name <- name
  Result.Table$Sample_Time <- Sampling.time.from.GF.End
  Result.Table$True_GF_length <- Result.Table$GF.End-Result.Table$GF.Start
  Result.Table$True_mean_GF <- ((Result.Table$GF.End+Result.Table$GF.Start)/2)-(Result.Table$GF.Start-Result.Table$Sample_Time)
  Result.Table$mean_GF_exp <- 1/Result.Table$s.exp
  Result.Table$mean_GF_lomax_s <- 1/Result.Table$s.lomax
  Result.Table.comparison <- True_params(Result.Table)
  Result.Table$True_W <- Result.Table.comparison$V1
  Result.Table$True_S <- Result.Table.comparison$V2
  #Result.Table.comparison$length_GF <- (sqrt(Result.Table$mean_GF_lomax_s/(((1/Result.Table$w.lomax))*Result.Table$s.lomax)))*4
  Result.Table.comparison$length_GF <- sqrt((1/Result.Table$s.lomax)^2*Result.Table$w.lomax)*4
  Result.Table$length_GF <- Result.Table.comparison$length_GF
  
  return(Result.Table)
}

Plot_all_together_samples_50_gen_flipped <- function(ggdata,cbPalette_viridis){
  ggdata$Model <- factor(ggdata$Model,
                          levels = c("Simple Pulse","Extended Pulse"),ordered = TRUE)
  ggdata$Name <- factor(ggdata$Name,
                        levels = c("Hudson_only_sim","Hybrid_sim"),ordered = TRUE)
  ggplot(data = ggdata, aes(y=factor(Name),x=as.numeric(as.character(value)),colour=factor(Name))) +
    geom_boxplot(show.legend = T)+ 
    #facet_grid(as.factor(True_GF_length)+as.factor(True_mean_GF) ~Model, switch = "y")+
    facet_grid(as.factor(Sample_Time)+as.factor(True_GF_length)+as.factor(True_mean_GF) ~Model, switch = "y")+
    geom_vline( aes(xintercept = True_mean_GF ))+
    labs(x = "Estimated Admixture Mean Time")+
    #labs(y = "Simulated Admixture Duration \n Simulated Admixture Mean")+
    labs(y = "Sampling Time \n Simulated Admixture Duration \n Simulated Admixture Mean")+
    theme(
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())+
    coord_cartesian(xlim = c(0,1000), expand = 0)+
    scale_x_continuous(breaks = seq(0, 1000, by = 500))+
    scale_color_manual("Simulations",
                       values = c(cbPalette_viridis[1],cbPalette_viridis[2]),
                       labels = c("Hudson only ","500 gen W-F then Hudson"),
                       guide = guide_legend(reverse=TRUE))
  
}


Plot_sampling_50_gen_GF_Length_flipped <- function(ggdata,cbPalette_viridis){
  ggdata$Name <- factor(ggdata$Name,
                        levels = c("Hudson_only_sim","Hybrid_sim"),ordered = TRUE)
  ggplot(ggdata,aes(y=variable,x=as.numeric(as.character(value)),colour=factor(Name)))+
    geom_boxplot(show.legend = F)+
    #facet_grid(as.factor(True_GF_length)+as.factor(True_mean_GF) ~ Model, switch = "y")+
    facet_grid(as.factor(Sample_Time)+as.factor(True_GF_length)+as.factor(True_mean_GF) ~Model, switch = "y")+
    geom_vline( aes(xintercept = True_GF_length ))+
    #ggtitle(Ptitle) +
    labs(y = "")+
    labs(x = "Estimated Admixture Duration")+
    theme(
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank())+
    coord_cartesian(xlim = c(0,2500), expand = 0)+
    scale_x_continuous(breaks = seq(0, 2500, by = 500))+
    scale_color_manual("Simulations",
                       values = c(cbPalette_viridis[1],cbPalette_viridis[2]),
                       labels = c("Hudson only ","500 gen W-F then Hudson"),
                       guide = guide_legend(reverse=TRUE))
}




Result.Table.path_Recent_50 <-'../Close_to_GF_End_Recent_GF_corrected/Result_both_Fit///Result_file_SIM_Raw_ALDER-Fit-Close_to_GF_End_Recent_GF_corrected-GF_Model_IV-min_dist_Fit-0.05-ascertainment-0-No_correction.txt'

Result.Table.path_Recent_50_WF <-'../Close_to_GF_End_Recent_GF_corrected_WF/Result_both_Fit_classic_Lomax/Result_file_SIM_Raw_ALDER-Fit-Close_to_GF_End_Recent_GF_corrected_WF-GF_Model_IV-min_dist_Fit-0.05-ascertainment-0-No_correction.txt'


Plot.data_50<-rbind(
  Recent_50_constant<- Result.Table.fn(Result.Table.path_Recent_50,50,'Hudson_only_sim'),
  Recent_50_WF<- Result.Table.fn(Result.Table.path_Recent_50_WF,50,'Hybrid_sim')
)

ggdata_t.GF_50_mean_GF_exp <- melt(Plot.data_50,measure.vars =  c('mean_GF_exp'),id.vars = c('True_mean_GF','True_GF_length','Name'))
ggdata_t.GF_50_mean_GF_lomax <- melt(Plot.data_50,measure.vars =  c('mean_GF_lomax_s'),id.vars = c('True_mean_GF','True_GF_length','Name'))
ggdata_l.GF_50 <- melt(Plot.data_50,measure.vars =  c('length_GF'),id.vars = c('True_mean_GF','True_GF_length','Name'))

ggdata_reodering_fn <- function(ggdata){
  ggdata$Name <- factor(ggdata$Name,
    levels = c("Hudson_only_sim","Hybrid_sim"),ordered = TRUE)
  return(ggdata)
}
```


``` {r figR3, message=FALSE, echo=FALSE,warning=FALSE,fig2.pos="H",fig.width=9,fig.height=10,fig.cap="\\label{fig:figR3} Comparison between the Hudson only and hybrid Wright-Fischer/Hudson simulations for parameter inference under the simple and extended pulse model  A) Mean time estimates $t_m$ for different gene flow durations $t_d$ all sampled 50 generations after the gene flow ended. B) Duration estimate $t_d$ of the same scenario"}

# Plot 50 gen from Admixture
ggdata_t.GF_50_mean_GF_exp$Model <- "Simple Pulse"
ggdata_t.GF_50_mean_GF_lomax$Model <- "Extended Pulse"
ggdata_all_together_samples_50_t_m <- rbind(ggdata_reodering_fn(ggdata_t.GF_50_mean_GF_exp),ggdata_reodering_fn(ggdata_t.GF_50_mean_GF_lomax))
ggdata_all_together_samples_50_t_m$Sample_Time <- 50
ggdata_sampling_50_gen_GF_Length <- ggdata_reodering_fn(ggdata_l.GF_50)
ggdata_sampling_50_gen_GF_Length$Model <- "Extended Pulse"
ggdata_sampling_50_gen_GF_Length$Sample_Time <- 50

Mean_GF_F_50 <- Plot_all_together_samples_50_gen_flipped(ggdata_all_together_samples_50_t_m,cbPalette_viridis)
Duration_GF_F_50 <- Plot_sampling_50_gen_GF_Length_flipped(ggdata_sampling_50_gen_GF_Length,cbPalette_viridis)
Constant_sampling_time <- ggarrange(Mean_GF_F_50,Duration_GF_F_50,labels = c("A","B"),
          ncol = 2, nrow = 1,widths = c(0.6,0.4),common.legend = T,legend = 'bottom')

Constant_sampling_time

```

## Comparing effect sizes for technical covariates now including downsampling


```{r eval=F, message=FALSE, echo=FALSE,warning=FALSE, cache=T}

##### GLM for the bais on the admixture dates #####


### Read in data ###
Read_GLM_indata <- function(path){
  Result.names <- c('A.exp', 's.exp', 'c.exp', 'RSS_Expo','AIC_Expo', 'A.lomax', 's.lomax', 'w.lomax','c.lomax', 'RSS_Lomax','AIC_Lomax', 'F_Test','Scenario.name','GF.Start','GF.End','AS','minDist','GF.Model')
  Result.Table=read.table("/mnt/scratch/leonardoi/Paper_Revisions/Fig_2_A_revision/Result_Fit/Result_file_SIM_Raw_ALDER-Fit-Fig_2_A_revision-GF_Model_IV-min_dist_Fit-0.02-ascertainmentI-downsampled100-ReccNo_correction.txt",header=F,sep = " ")
  return(Result.Table)
}



Simple_D_Sim_1 <- Read_GLM_indata("/mnt/scratch/leonardoi/Paper_Revisions/Fig_2_A_revision/Result_Fit/Result_file_SIM_Raw_ALDER-Fit-Fig_2_A_revision-GF_Model_IV-min_dist_Fit-0.02-ascertainmentI-downsampled100-ReccNo_correction.txt")
Simple_D_Sim_1$Demography <- "0_Simple"
Simple_D_Sim_1$Recomb.rate <- "0_constant"
Simple_D_Sim_1$Sim_id <- ifelse(Simple_D_Sim_1$Ascertained==0,"Demo_simple_Recomb_const_LES_min_d_2","Demo_simple_Recomb_const_HES_min_d_2")



######## model with response being the difference between the estimated Admixture time and the true one #####
# full model with Ascertainement, min dist, Demographi and recombination rate as predictore but no interactions
xdata.M.3 <- rbind(Simple_D_Sim_1,Simple_D_Sim_2,Recom_Sim_1,Recom_Sim_2,Inferred_D_Sim_1,Inferred_D_Sim_2,Recom_Sim_and_Inf_1,Recom_Sim_and_Inf_2)
rm(Simple_D_Sim_1,Simple_D_Sim_2,Recom_Sim_1,Recom_Sim_2,Inferred_D_Sim_1,Inferred_D_Sim_2,Recom_Sim_and_Inf_1,Recom_Sim_and_Inf_2)
xdata.M.3$TID <- ifelse(xdata.M.3$GF=='0_Pulse',paste(xdata.M.3$Sim_id,'GF_model_Pulse',sep = '_'),paste(xdata.M.3$Sim_id,'GF_model_Continuous',sep = '_')) 


#xdata.M.3$Diff <- xdata.M.3$m - xdata.M.3$mean.t.GF
xdata.M.3$Diff <- xdata.M.3$m - xdata.M.3$Gamma_mean
# remove all estimates where nls reported an error
n_error=xdata.M.3[xdata.M.3$error=="nls_error",]
xdata.M.3_no_error <- xdata.M.3[xdata.M.3$error=="no_error",]
xdata.M.3_no_error$Sim_id_int <- as.integer(as.factor(xdata.M.3_no_error$TID))

xdata.M.3_no_error$Diff_s <- (xdata.M.3_no_error$m - xdata.M.3_no_error$Gamma_mean)/sd(xdata.M.3_no_error$m)



Bdata_index_s_2 <- list(
  E = (xdata.M.3_no_error$Diff_s),
  Id = xdata.M.3_no_error$Sim_id_int,
  A = ifelse(xdata.M.3_no_error$Ascertained==0,0,1),
  MD = ifelse(xdata.M.3_no_error$min_dist=="0.05",0,1),
  D = ifelse(xdata.M.3_no_error$Demography=="0_Simple",0,1),
  R = ifelse(xdata.M.3_no_error$Recomb.rate=="0_constant",0,1),
  GF = ifelse(xdata.M.3_no_error$GF=="0_Pulse",0,1)
)



Effect_size_fixed_s_2 <- ulam(
  alist(
    E ~ dnorm(mu,sigma),
    mu <- a + bA*A + bm*MD + bD*D + bR*R + bG*GF ,
    a ~ dnorm( 0 , 2 ),
    c(bA,bm,bD,bR,bG) ~ dnorm( 0 , 2 ),
    sigma ~ dexp(1)
  ), data=Bdata_index_s_2, chains=4 , cores=4 , log_lik = T)

```

### changing Plots

```{r message=FALSE, echo=FALSE,warning=FALSE}

# New Data
Figure_1_A_Data <- Results_Table("Fig_1_Results_corrected/Result_file_SIM_Raw_ALDER-Fit-Fig_1_A_corrected-GF_Model_IV-min_dist_Fit-0.05-ascertainment-0.txt")
Figure_1_A_Data <- Figure_1_A_Data[Figure_1_A_Data$error=="no_error",]
Figure_1_B_Data <- Results_Table("Fig_1_Results_corrected/Result_file_SIM_Raw_ALDER-Fit-Fig_1_B_corrected-GF_Model_IV-min_dist_Fit-0.05-ascertainment-0.txt")


Fig_A_1 <- Get_Data_Table(Figure_1_A_Data)
Fig_A_1$Var1 <- as.numeric(as.character(Fig_A_1$Var1))
Fig_A_1$Var3 <- round(as.numeric(as.character(Fig_A_1$Var3)))
Fig_A_1_Means <- aggregate(Fig_A_1[,c(1,3)],list(Fig_A_1$Var2), mean)
Fig_A_1_Means_diff <- data.frame(sqrt((Fig_A_1_Means$Var1-Fig_A_1_Means$Var3)^2)/Fig_A_1_Means$Var3)
Fig_A_1_Means_diff_pulse <- round(range(Fig_A_1_Means_diff[1:5,]*100))
Fig_A_1_Means_diff_continuous <- round(range(Fig_A_1_Means_diff[6:10,]*100))

Fig_B_1 <- Get_Data_Table(Figure_1_B_Data)
Fig_B_1$Var7 <- rep('xx',length(Fig_B_1$Var1))
Fig_B_1_Means <- data.frame(est=rep(as.numeric(as.character(Fig_B_1$Var1)),Fig_B_1$Freq),
                               duration=rep(as.numeric(as.character(Fig_B_1$Var6)),Fig_B_1$Freq))
Fig_1_B_Means_per_duration <- Fig_B_1_Means %>%
    group_by(duration) %>% 
    summarise_each(funs(mean))

Fig_1_B_Means_per_duration$relative_dif <- abs(1-(1500/Fig_1_B_Means_per_duration$est))

```

```{r fig2,message=FALSE, echo=FALSE,warning=FALSE,fig2.pos="H",fig.width=9,fig.height=9,fig.cap="\\label{fig:fig2} A) Comparison of mean admixture time estimates between simple and extended pulse gene flow for different admixture times. The duration of continuous gene flow $t_d$ corresponds to 50% of the mean admixture time $t_m$, black line indicates true mean admixture time. B) Comparison of mean admixture time estimates for simulations with a mean time of admixture of 1500 generations ago, at a varying durations of gene flow. Boxplot created from 100 simulation replicates, respectively."}

######################## GG PLotting ###########################
cbPalette_viridis <- viridis(length(t_d),option = "D")
## ggplot Figure 1 A
Plot_Fig_1_A <- function(Data,Colour_P){
  Px <-  ggplot(Data,aes(x=Var4,y=as.numeric(as.character(Var1)),colour=factor(Var4)))+
    geom_point(aes(size = Freq),show.legend = F)+
    geom_boxplot()+
    facet_grid(~as.factor(Var3),switch = "x")+
    geom_hline( aes(yintercept = as.numeric(as.character(Data$Var3)) ))+
    labs(x = "True Admixture Time")+
    labs(y = "Estimated Admixture Time")+
    theme(
      axis.text.x=element_blank(),
      axis.ticks.x=element_blank())+
    coord_cartesian(ylim = c(0,2500), expand = 0)+
    scale_color_manual("Gene Flow Model",
                       values = c(Colour_P[1],Colour_P[6]),
                       labels = c("Simple Pulse","Extended Pulse"))
  return(Px)
  
}


### Figure 1 ggplot ###
Plot_Fig_1_B <- function(Data,Colour_P){
  Px <-  ggplot(Data,aes(x=Var7,y=as.numeric(as.character(Var1)),colour=factor(Var4)))+
  #Px <-  ggplot(Data,aes(x=Var7,y=as.numeric(as.character(Var1))))+
    geom_point(aes(size = Freq),show.legend = F)+
    geom_boxplot()+
    facet_grid(~as.factor(Var6),switch = "x")+
    geom_hline( aes(yintercept = 1500 ))+
    theme(
      axis.text.x=element_blank(),
      axis.ticks.x=element_blank())+
    labs(x = "Admixture Duration")+
    labs(y = "Estimated Admixture Time")+
    scale_color_manual("Gene Flow Model",
                       values = c(Colour_P[1],Colour_P[6],Colour_P[6],Colour_P[6],Colour_P[6],Colour_P[6]),
                       labels = c("Simple Pulse","Extended Pulse","Extended Pulse","Extended Pulse","Extended Pulse","Extended Pulse"))
  return(Px)
  
}

### Plot in one window

P1_1 <- Plot_Fig_1_A(Fig_A_1,Colour_P = cbPalette_viridis)
P1_2 <- Plot_Fig_1_B(Fig_B_1,Colour_P = cbPalette_viridis)

ggarrange(P1_1,P1_2,
          labels = c("A","B"),
          ncol = 2, nrow = 2,common.legend = T,legend = 'top', align = "h")

```